package main

import (
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"
)

var (
	verbose  = flag.Bool("verbose", true, "verbose logging")
	debug    = flag.Bool("debug", false, "print instead of redirect")
	port     = flag.Int("port", 8080, "port to listen on")
	hostname = flag.String("hostname", "localhost", "hostname of this server")
	action   = flag.String("action", "lookup", "action [lookup|addwww|removewww|api]")
	endpoint = flag.String("endpoint", "https://admin.redirect2.me/api/lookup.json", "endpoint https://www.example.com/api/lookup.json")

	supportUrl = "https://www.redirect2.me/support/${error}.html"

	logger  = log.New(os.Stdout, "R2ME: ", log.Ldate|log.Ltime|log.Lmicroseconds|log.LUTC)
	mapFunc func(*http.Request) (string, int)
)

func customDNSDialer(ctx context.Context, network, address string) (net.Conn, error) {
	d := net.Dialer{}
	return d.DialContext(ctx, "udp", "1.1.1.1:53")
}

func makeError(errcode string) (string, int) {
	return strings.Replace(supportUrl, "${error}", errcode, -1), http.StatusTemporaryRedirect
}

func getScheme(r *http.Request) string {

	proxyValue := r.Header.Get("X-Forwarded-Proto")
	if proxyValue != "" {
		return proxyValue
	}

	urlValue := r.URL.Scheme
	if urlValue != "" {
		return urlValue
	}

	return "http"
}

func lookupLow(domain string) string {
	prefix := "redirect2me="

	r := net.Resolver{
		PreferGo: true,
		Dial:     customDNSDialer,
	}

	results, err := r.LookupTXT(context.Background(), domain)

	if err != nil || len(results) == 0 {
		return ""
	}

	for rIndex := 0; rIndex < len(results); rIndex++ {
		result := results[rIndex]
		logger.Printf("INFO: %s(%d): %s\n", domain, rIndex, result)
		if len(result) > len(prefix)+1 && result[0:len(prefix)] == prefix {
			return results[rIndex][len(prefix):]
		}
	}

	return ""
}

func mapAddWww(r *http.Request) (string, int) {

	host := r.Host

	if strings.HasPrefix(host, "www.") {
		return makeError("error-already-has-www")
	}

	loc := url.URL(*r.URL)
	loc.Scheme = getScheme(r)
	loc.Host = "www." + host
	return loc.String(), http.StatusTemporaryRedirect
}

type ApiResponse struct {
	Destination string `json:"destination"`
	StatusCode  int    `json:"status_code"`
	Success     bool   `json:"success"`
}

func mapApi(r *http.Request) (string, int) {

	source := url.URL(*r.URL)
	source.Host = r.Host
	source.Scheme = getScheme(r)

	data := make(map[string]string)
	data["source"] = source.String()
	data["uri"] = r.RequestURI
	data["user-agent"] = r.Header.Get("user-agent")
	data["referrer"] = r.Header.Get("referer")
	data["remote-addr"] = r.RemoteAddr

	// encode request
	buf, err := json.Marshal(data)
	if err != nil {
		return makeError("api-prep-error")
	}

	// obtain certificate
	res, err := http.Post(*endpoint, "application/json", bytes.NewReader(buf))
	if err != nil {
		return makeError("api-call-error")
	}

	defer res.Body.Close()

	// check code
	if res.StatusCode != 200 {
		return makeError("api-invalid-server-response-code")
	}

	body, err := ioutil.ReadAll(res.Body)

	// decode response
	var apiResp ApiResponse
	err = json.Unmarshal(body, &apiResp)
	if err != nil {
		return makeError("api-invalid-server-response-json")
	}

	//LATER: check that Destination is a valid url
	u, err := url.Parse(apiResp.Destination)
	if err != nil {
		return makeError("api-invalid-server-response-url")
	}

	//expand given URL with stuff from original
	result := url.URL(*r.URL)
	if u.Scheme == "" {
		result.Scheme = getScheme(r)
	} else {
		result.Scheme = u.Scheme
	}
	result.Host = u.Host
	if u.Path != "" {
		result.Path = u.Path
	}
	if u.RawQuery != "" {
		result.RawQuery = u.RawQuery
	}
	return result.String(), apiResp.StatusCode
}

func mapRemoveWww(r *http.Request) (string, int) {

	host := r.Host

	if !strings.HasPrefix(host, "www.") {
		return makeError("error-does-not-have-www")
	}

	loc := url.URL(*r.URL)
	loc.Scheme = getScheme(r)
	loc.Host = host[4:]
	return loc.String(), http.StatusTemporaryRedirect
}

func mapLookup(r *http.Request) (string, int) {

	host := r.Host

	lookup := lookupLow(host)

	if lookup == "" {
		return makeError("error-lookup-not-found")
	}

	u, err := url.Parse(lookup)
	if err != nil {
		return makeError("lookup-parse-error")
	}

	result := url.URL(*r.URL)
	if u.Scheme == "" {
		result.Scheme = getScheme(r)
	} else {
		result.Scheme = u.Scheme
	}
	result.Host = u.Host
	if u.Path != "" {
		result.Path = u.Path
	}
	if u.RawQuery != "" {
		result.RawQuery = u.RawQuery
	}
	return result.String(), http.StatusTemporaryRedirect
}

func redirect_handler(w http.ResponseWriter, r *http.Request) {

	/* LATER:
	   if (isAddress(r)) {
	       return makeError("error-host-is-ip-address");
	   }
	*/
	// Add CORS headers
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.Header().Set("Access-Control-Allow-Methods", "GET, OPTIONS")
	w.Header().Set("Access-Control-Max-Age", "604800")

	if r.Method == "OPTIONS" {
		w.WriteHeader(http.StatusOK)
		return
	}

	destination, status_code := mapFunc(r)

	if *verbose == true {
		logger.Printf("INFO: redirecting from '%s' to '%s'\n", r.URL.String(), destination)
	}
	if *debug == true {
		fmt.Fprintf(w, "DEBUG: redirect %d to '%s'\n", status_code, destination)
	} else {
		http.Redirect(w, r, destination, status_code)
	}

	data := make(map[string]string)
	data["source_host"] = r.Host
	data["source_url"] = r.URL.String()
	data["uri"] = r.RequestURI
	data["destination"] = destination
	data["user-agent"] = r.Header.Get("user-agent")
	data["referrer"] = r.Header.Get("referer")
	data["path"] = r.URL.Path
	data["remote-addr"] = r.RemoteAddr
	//LATER: ip address

	extraJson, err := json.Marshal(data)
	if err != nil {
		logger.Panicf("ERROR: unable convert extra data to JSON %s\n", err)
		return
	}

	logger.Printf("INFO: %s\n", extraJson)
}

func www_handler(w http.ResponseWriter, r *http.Request) {
	http.Redirect(w, r, "https://www.redirect2.me/", http.StatusTemporaryRedirect)
}

func robotsTxtHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/plain; charset=utf8")
	w.Write([]byte(`#
# robots.txt for redirect2.me servers
#
#
# this server redirects all incoming requests: there is nothing here to index
#

User-Agent: *
Disallow: /`))
}

func faviconSvgHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "image/svg+xml; charset=utf8")
	w.Write([]byte(`<svg xmlns="http://www.w3.org/2000/svg" id="svg211" width="64" height="64"><style id="style2">.st1{display:inline}.st3{fill:none;stroke:#231f20;stroke-width:200;stroke-miterlimit:10}.st6{display:inline;fill:#231f20}</style><g id="Layer_2" transform="matrix(.05987 0 0 .05987 -5.166 -4.023)"><g id="g208"><linearGradient id="SVGID_10_" gradientUnits="userSpaceOnUse" x1="686.202" y1="119.745" x2="686.202" y2="1101.215"><stop offset=".042" id="stop172" stop-color="#8fdafd"/><stop offset=".196" id="stop174" stop-color="#8dd8fc"/><stop offset=".252" id="stop176" stop-color="#86d1f9"/><stop offset=".287" id="stop178" stop-color="#7cc7f5"/><stop offset=".365" id="stop180" stop-color="#66b9e9"/><stop offset=".421" id="stop182" stop-color="#5cb2e4"/><stop offset=".619" id="stop184" stop-color="#3eb7f0"/><stop offset=".911" id="stop186" stop-color="#1abafd"/></linearGradient><path d="M737.6 422.8h153.2L620.2 119.7 349.6 422.8h153.2v678.4h234.8V917.1c17.7 7.7 36.2 14.3 55.6 19.8 50.9 14.6 108.3 21.9 171.3 21.9 18.9 0 38.4-.7 58.3-2V721.4c-86.3 7.6-190.4 2.2-242.7-54.8-24.2-26.4-38.2-64.2-41.7-112.4z" id="path189" fill="url(#SVGID_10_)"/><linearGradient id="SVGID_11_" gradientUnits="userSpaceOnUse" x1="664.63" y1="67.231" x2="664.63" y2="1136.19"><stop offset=".035" id="stop191" stop-color="#4692cc"/><stop offset=".161" id="stop193" stop-color="#377bb6"/><stop offset=".175" id="stop195" stop-color="#377bb6"/><stop offset=".259" id="stop197" stop-color="#377bb6"/><stop offset=".666" id="stop199" stop-color="#24629c"/><stop offset=".893" id="stop201" stop-color="#1a508b"/><stop offset=".976" id="stop203" stop-color="#25476b"/></linearGradient><path d="M772.6 1136.2H467.8V457.8H271.4L620.2 67.2l348.7 390.6H772.8l.6 95c3.1 39.7 14 70 32.5 90.2 18.4 20 48.2 33.8 88.8 40.8 35 6.1 77.1 7 125.1 2.8l38-3.3v306.4l-32.7 2.2c-20.6 1.4-41 2.1-60.7 2.1-66.2 0-127.1-7.8-180.9-23.3-3.7-1.1-7.4-2.2-11-3.3v168.8zm-234.9-70h164.9V863.9l48.9 21.2c16.2 7 33.5 13.2 51.4 18.3 47.6 13.7 102 20.6 161.6 20.6 7.7 0 15.5-.1 23.4-.3v-165c-38.8 1.4-74-.6-105.1-6-56.1-9.7-99.3-30.8-128.4-62.5-29.6-32.3-46.7-77.2-50.8-133.5l-.1-1.2v-1.2l-1-166.5h110.3L620.2 172.3 427.7 387.8h110.1v678.4z" id="path206" fill="url(#SVGID_11_)"/></g></g></svg>`))
}

var faviconIco = []byte{
	0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x68, 0x04,
	0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x04, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x33, 0x72, 0x3a,
	0x02, 0xa7, 0x97, 0x4c, 0x02, 0xcd, 0x97, 0x4c, 0x02, 0xcd, 0x72, 0x3a, 0x02, 0xa7, 0x00, 0x00,
	0x00, 0x33, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x23, 0x00, 0x00, 0x00, 0x13, 0x00, 0x00,
	0x00, 0x07, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x19, 0x9b, 0x50,
	0x05, 0xcd, 0xff, 0xba, 0x18, 0xff, 0xff, 0xb9, 0x16, 0xff, 0x9b, 0x50, 0x05, 0xcd, 0x00, 0x00,
	0x00, 0x1b, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00,
	0x00, 0x05, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xa0, 0x55,
	0x08, 0xcd, 0xff, 0xba, 0x15, 0xff, 0xff, 0xb9, 0x13, 0xff, 0xa0, 0x55, 0x08, 0xcd, 0xa1, 0x56,
	0x09, 0x2b, 0xa0, 0x55, 0x08, 0x7b, 0xa0, 0x55, 0x08, 0xab, 0xa0, 0x55, 0x08, 0xc5, 0xa1, 0x56,
	0x09, 0x99, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xa6, 0x5b,
	0x0d, 0xcd, 0xff, 0xbb, 0x1b, 0xff, 0xff, 0xba, 0x18, 0xff, 0xa6, 0x5b, 0x0d, 0xcd, 0xb3, 0x69,
	0x11, 0xcf, 0xd7, 0x91, 0x18, 0xe9, 0xf1, 0xaa, 0x14, 0xf7, 0xfc, 0xb7, 0x17, 0xfd, 0xa6, 0x5b,
	0x0d, 0xcd, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xac, 0x61,
	0x11, 0xcd, 0xff, 0xbc, 0x22, 0xff, 0xff, 0xb9, 0x19, 0xff, 0xcd, 0x88, 0x1e, 0xdf, 0xf9, 0xb3,
	0x16, 0xfb, 0xfe, 0xb3, 0x06, 0xff, 0xff, 0xb6, 0x0d, 0xff, 0xff, 0xbb, 0x1e, 0xff, 0xac, 0x61,
	0x11, 0xcd, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xb2, 0x67,
	0x16, 0xcd, 0xf9, 0xbb, 0x2e, 0xff, 0xf7, 0xad, 0x0d, 0xff, 0xf6, 0xb0, 0x18, 0xff, 0xf8, 0xb1,
	0x14, 0xff, 0xe6, 0xa4, 0x2a, 0xef, 0xc7, 0x80, 0x20, 0xd9, 0xb7, 0x6d, 0x19, 0xcf, 0xb1, 0x66,
	0x16, 0x85, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xb9, 0x6e,
	0x1b, 0xcd, 0xf2, 0xb8, 0x3d, 0xff, 0xec, 0xa6, 0x19, 0xff, 0xee, 0xab, 0x23, 0xff, 0xd7, 0x96,
	0x31, 0xe5, 0xb9, 0x6e, 0x1b, 0xab, 0xb8, 0x6d, 0x1b, 0x3f, 0xb7, 0x6c, 0x1a, 0x0f, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xc0, 0x75,
	0x20, 0xcd, 0xeb, 0xb5, 0x4d, 0xff, 0xe1, 0xa0, 0x2b, 0xff, 0xe1, 0xa8, 0x47, 0xef, 0xc0, 0x75,
	0x20, 0xab, 0xbc, 0x71, 0x1e, 0x13, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xc7, 0x7c,
	0x25, 0xcd, 0xe5, 0xb3, 0x5c, 0xff, 0xdd, 0xa5, 0x49, 0xff, 0xd3, 0x92, 0x3c, 0xd9, 0xc6, 0x7b,
	0x25, 0x3f, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xcd, 0x82,
	0x2a, 0xcd, 0xf1, 0xc3, 0x76, 0xff, 0xeb, 0xba, 0x6d, 0xff, 0xd0, 0x88, 0x31, 0xcf, 0xcd, 0x82,
	0x2a, 0x0f, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xd4, 0x89,
	0x2f, 0xcd, 0xf6, 0xc8, 0x7c, 0xff, 0xf5, 0xc8, 0x7c, 0xff, 0xd4, 0x89, 0x2f, 0xcd, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xdb, 0x90, 0x35, 0x99, 0xda, 0x8f, 0x34, 0xcd, 0xda, 0x8f,
	0x34, 0xcd, 0xf8, 0xcd, 0x81, 0xff, 0xf8, 0xcd, 0x81, 0xff, 0xda, 0x8f, 0x34, 0xcd, 0xda, 0x8f,
	0x34, 0xcd, 0xdb, 0x90, 0x35, 0x99, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xdf, 0x94, 0x38, 0x5d, 0xdf, 0x94, 0x38, 0xcd, 0xfb, 0xd4,
	0x88, 0xff, 0xf8, 0xc7, 0x7b, 0xff, 0xf8, 0xc7, 0x7b, 0xff, 0xfb, 0xd3, 0x87, 0xff, 0xdf, 0x94,
	0x38, 0xcd, 0xdf, 0x94, 0x38, 0x5d, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xe4, 0x99, 0x3b, 0x5d, 0xe4, 0x99,
	0x3b, 0xcd, 0xfe, 0xdb, 0x8f, 0xff, 0xfe, 0xdb, 0x8f, 0xff, 0xe4, 0x99, 0x3b, 0xcd, 0xe4, 0x99,
	0x3b, 0x5d, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xe8, 0x9d,
	0x3f, 0x5d, 0xe8, 0x9d, 0x3f, 0xcd, 0xe8, 0x9d, 0x3f, 0xcd, 0xe8, 0x9d, 0x3f, 0x5d, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xea, 0x9f, 0x40, 0x49, 0xea, 0x9f, 0x40, 0x49, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff,
	0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
}

func faviconIcoHandler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "image/vnd.microsoft.icon")
	w.Write(faviconIco)
}

func main() {

	flag.Parse()

	switch *action {
	case "lookup":
		mapFunc = mapLookup
	case "addwww":
		mapFunc = mapAddWww
	case "api":
		mapFunc = mapApi
	case "removewww":
		mapFunc = mapRemoveWww
	default:
		logger.Panicf("ERROR: invalid action '%s'\n", *action)
	}

	if *debug {
		logger.Printf("DEBUG: running in debug mode\n")
	}

	http.HandleFunc("/", redirect_handler)
	http.HandleFunc(*hostname+"/status.json", statusHandler)
	http.HandleFunc(*hostname+"/", www_handler)
	http.HandleFunc(*hostname+"/robots.txt", robotsTxtHandler)
	http.HandleFunc(*hostname+"/favicon.ico", faviconIcoHandler)
	http.HandleFunc(*hostname+"/favicon.svg", faviconSvgHandler)

	if *verbose {
		logger.Printf("INFO: hostname is %s\n", *hostname)
		logger.Printf("INFO: action is %s\n", *action)
		logger.Printf("INFO: listen pid is %s\n", os.Getenv("LISTEN_PID"))
		logger.Printf("INFO: listen fds is %s\n", os.Getenv("LISTEN_FDS"))
		logger.Printf("INFO: listen fdnames is %s\n", os.Getenv("LISTEN_FDNAMES"))
	}
	if os.Getenv("LISTEN_PID") == strconv.Itoa(os.Getpid()) {
		if *verbose {
			logger.Printf("INFO: listening on systemd socket\n")
		}
		// systemd run
		f := os.NewFile(3, "from systemd")
		l, err := net.FileListener(f)
		if err != nil {
			log.Fatal(err)
		}
		http.Serve(l, nil)
	} else {
		if *verbose {
			logger.Printf("INFO: running on port %d\n", *port)
		}
		err := http.ListenAndServe(":"+strconv.Itoa(*port), nil)
		if err != nil {
			logger.Panicf("ERROR: unable to listen on port %d: %s\n", *port, err)
		}
	}

}
